using System;using System.Collections.Generic;using System.Linq;public enum Room{    Undecided,    Start,    Hall,    RightDeadEnd,    LeftDeadEnd,    DropTop,    DropBottom,    EndHall,    EndLeftDeadEnd,    EndRightDeadEnd,    Full,}public enum Position{    Up,    Down,    Left,    Right}public struct Rule{    public Rule(Room room1, Room room2, Position position)    {        Room1 = room1;        Room2 = room2;        RelPosition = position;    }        public Room Room1 { get; }    public Room Room2 { get; }    public Position RelPosition { get; }}public struct UndecidedInfo{    public UndecidedInfo(int index, List<Room> possibleRooms)    {        Index = index;        PossibleRooms = possibleRooms;    }        public int Index { get; }    public List<Room> PossibleRooms { get; }}public struct WeightInfo{    public WeightInfo(Room room, int weight)    {        Room2 = room;        Weight = weight;    }        public Room Room2 { get; }    public int Weight { get; }}public enum Cell{    Full,    Empty,    Lava,    Spawn,    Win,    NPC,    Duck,    Enemy,    Debug,    Decoration,    PossibleFull,}namespace hacktest{    class Program    {        static void Main(string[] args)        {            List<Rule> rules = new List<Rule>();            rules.Add(new Rule(Room.DropBottom, Room.Hall, Position.Down));            rules.Add(new Rule(Room.DropBottom, Room.LeftDeadEnd, Position.Down));            rules.Add(new Rule(Room.DropBottom, Room.RightDeadEnd, Position.Down));            rules.Add(new Rule(Room.DropBottom, Room.DropBottom, Position.Down));            rules.Add(new Rule(Room.DropBottom, Room.DropBottom, Position.Up));            rules.Add(new Rule(Room.Hall, Room.DropBottom, Position.Up));            rules.Add(new Rule(Room.Hall, Room.LeftDeadEnd, Position.Up));            rules.Add(new Rule(Room.Hall, Room.RightDeadEnd, Position.Up));            rules.Add(new Rule(Room.DropTop, Room.Hall, Position.Up));            rules.Add(new Rule(Room.DropTop, Room.LeftDeadEnd, Position.Up));            rules.Add(new Rule(Room.DropTop, Room.RightDeadEnd, Position.Up));            rules.Add(new Rule(Room.DropTop, Room.DropTop, Position.Down));            rules.Add(new Rule(Room.DropTop, Room.DropTop, Position.Up));            rules.Add(new Rule(Room.Hall, Room.DropTop, Position.Down));            rules.Add(new Rule(Room.LeftDeadEnd, Room.DropTop, Position.Down));            rules.Add(new Rule(Room.RightDeadEnd, Room.DropTop, Position.Down));            rules.Add(new Rule(Room.DropBottom, Room.Start, Position.Down));            rules.Add(new Rule(Room.LeftDeadEnd, Room.Hall, Position.Left));            rules.Add(new Rule(Room.RightDeadEnd, Room.Hall, Position.Right));            rules.Add(new Rule(Room.Hall, Room.LeftDeadEnd, Position.Right));            rules.Add(new Rule(Room.Hall, Room.RightDeadEnd, Position.Left));            rules.Add(new Rule(Room.LeftDeadEnd, Room.Start, Position.Left));            rules.Add(new Rule(Room.RightDeadEnd, Room.Start, Position.Left));            rules.Add(new Rule(Room.LeftDeadEnd, Room.LeftDeadEnd, Position.Left));            rules.Add(new Rule(Room.RightDeadEnd, Room.RightDeadEnd, Position.Left));            rules.Add(new Rule(Room.LeftDeadEnd, Room.LeftDeadEnd, Position.Right));            rules.Add(new Rule(Room.RightDeadEnd, Room.RightDeadEnd, Position.Right));            rules.Add(new Rule(Room.LeftDeadEnd, Room.DropBottom, Position.Left));            rules.Add(new Rule(Room.RightDeadEnd, Room.DropBottom, Position.Right));            rules.Add(new Rule(Room.DropBottom, Room.LeftDeadEnd, Position.Right));            rules.Add(new Rule(Room.DropBottom, Room.RightDeadEnd, Position.Left));            rules.Add(new Rule(Room.LeftDeadEnd, Room.DropTop, Position.Left));            rules.Add(new Rule(Room.RightDeadEnd, Room.DropTop, Position.Right));            rules.Add(new Rule(Room.DropTop, Room.LeftDeadEnd, Position.Right));            rules.Add(new Rule(Room.DropTop, Room.RightDeadEnd, Position.Left));            rules.Add(new Rule(Room.RightDeadEnd, Room.LeftDeadEnd, Position.Left));            rules.Add(new Rule(Room.RightDeadEnd, Room.LeftDeadEnd, Position.Right));            rules.Add(new Rule(Room.LeftDeadEnd, Room.RightDeadEnd, Position.Right));            rules.Add(new Rule(Room.LeftDeadEnd, Room.RightDeadEnd, Position.Left));            List<WeightInfo> weights = new List<WeightInfo>();            weights.Add(new WeightInfo(Room.Hall, 160));            weights.Add(new WeightInfo(Room.LeftDeadEnd, 17));            weights.Add(new WeightInfo(Room.RightDeadEnd, 17));            weights.Add(new WeightInfo(Room.DropBottom, 1));            weights.Add(new WeightInfo(Room.DropTop, 55));            Map map;                        while (true)            {                map = new Map(rules, weights);                            map.Collapse();                if (map.PlaceEnd() > 25)                {                    break;                }            }            map.Display();            Grid grid = new Grid(map);        }    }        public class Map    {        public static int width = 13;        public static int height = 7;        public static Random _rnd = new Random();            private List<Rule> Rules;        private List<WeightInfo> Weights;            public Room[] MapData;        private List<UndecidedInfo> UndecidedRooms;            public Map(List<Rule> rules, List<WeightInfo> weights)        {            MapData = new Room[width * height];            Array.Fill(MapData, Room.Undecided);                UndecidedRooms = new List<UndecidedInfo>();                for (int i = 1; i < width * height; i++)            {                UndecidedRooms.Add(new UndecidedInfo(                        i,                        new Room[] { Room.Hall, Room.DropBottom, Room.DropTop,                            Room.LeftDeadEnd, Room.RightDeadEnd }.ToList()                    )                );            }                Rules = rules;            Weights = weights;                            Place(0, Room.Start);        }                void Place(int index, Room room)        {            MapData[index] = room;            for (int i = 0; i < UndecidedRooms.Count; i++)            {                if (UndecidedRooms[i].Index == index)                {                    UndecidedRooms.RemoveAt(i);                    break;                }            }                if (index >= width)            {                for (int i = 0; i < UndecidedRooms.Count; i++)                {                    if (UndecidedRooms[i].Index == index - width)                    {                        for (int j = 0; j < UndecidedRooms[i].PossibleRooms.Count(); j++)                        {                            if (InRules(UndecidedRooms[i].PossibleRooms[j], room, Position.Up))                            {                                UndecidedRooms[i].PossibleRooms.RemoveAt(j);                                j--;                            }                        }                        break;                    }                }            }                        if (index < width * (height - 1))            {                for (int i = 0; i < UndecidedRooms.Count; i++)                {                    if (UndecidedRooms[i].Index == index + width)                    {                        for (int j = 0; j < UndecidedRooms[i].PossibleRooms.Count(); j++)                        {                            if (InRules(UndecidedRooms[i].PossibleRooms[j], room, Position.Down))                            {                                UndecidedRooms[i].PossibleRooms.RemoveAt(j);                                j--;                            }                        }                        break;                    }                                    }            }                        if (index % width > 0)            {                for (int i = 0; i < UndecidedRooms.Count; i++)                {                    if (UndecidedRooms[i].Index == index - 1)                    {                        for (int j = 0; j < UndecidedRooms[i].PossibleRooms.Count(); j++)                        {                            if (InRules(UndecidedRooms[i].PossibleRooms[j], room, Position.Right))                            {                                UndecidedRooms[i].PossibleRooms.RemoveAt(j);                                j--;                            }                        }                        break;                    }                }            }                        if (index % width < width - 1)            {                for (int i = 0; i < UndecidedRooms.Count; i++)                {                    if (UndecidedRooms[i].Index == index + 1)                    {                        for (int j = 0; j < UndecidedRooms[i].PossibleRooms.Count(); j++)                        {                            if (InRules(UndecidedRooms[i].PossibleRooms[j], room, Position.Left))                            {                                UndecidedRooms[i].PossibleRooms.RemoveAt(j);                                j--;                            }                        }                        break;                    }                }            }                        UndecidedRooms.Sort(delegate(UndecidedInfo a, UndecidedInfo b)            {                return a.PossibleRooms.Count.CompareTo(b.PossibleRooms.Count);            });        }                bool InRules(Room a, Room b, Position c)        {            foreach (var rule in Rules)            {                if (rule.Room1 == a && rule.Room2 == b && rule.RelPosition == c)                {                    return true;                }            }            return false;        }                public void Display()        {            for (int i = 0; i < height; i++)            {                for (int j = 0; j < width; j++)                {                    Console.Write(MapData[i * width + j]);                    Console.Write(" ");                }                Console.WriteLine();            }        }                public void Collapse()        {            if (UndecidedRooms.Count == 0)            {                return;            }                int totalweight = 0;            foreach (var room in UndecidedRooms[0].PossibleRooms)            {                foreach (var weight in Weights)                {                    if (weight.Room2 == room)                    {                        totalweight += weight.Weight;                        break;                    }                }            }                            int ranNum = _rnd.Next(0, totalweight);                Room roomToPlace = Room.Full;                            foreach (var room in UndecidedRooms[0].PossibleRooms)            {                foreach (var weight in Weights)                {                    if (weight.Room2 == room)                    {                        if (weight.Weight > ranNum)                        {                            roomToPlace = room;                            break;                        }                        ranNum -= weight.Weight;                        break;                    }                }            }                            Place(UndecidedRooms[0].Index, roomToPlace);            Collapse();        }        public int PlaceEnd()        {            List<int> frontier = new []{ 0 }.ToList();            int depth = 0;            List<int> visited = new List<int>();            while (true)            {                List<int> new_frontier = new List<int>();                foreach (var node in frontier)                {                    if (node >= width)                    {                        if (!visited.Contains(node - width) && MapData[node - width] == Room.DropTop)                        {                            new_frontier.Add(node - width);                            visited.Add(node - width);                        }                    }                    if (node < width * (height - 1))                    {                        if (!visited.Contains(node + width) && MapData[node + width] == Room.DropBottom)                        {                            new_frontier.Add(node + width);                            visited.Add(node + width);                        }                    }                    if (node % width > 0)                    {                        if (!visited.Contains(node - 1) && MapData[node - 1] != Room.Full                                                        && MapData[node - 1] != Room.LeftDeadEnd)                        {                            new_frontier.Add(node - 1);                            visited.Add(node - 1);                        }                    }                    if (node % width < width - 1)                    {                        if (!visited.Contains(node + 1) && MapData[node + 1] != Room.Full                                                        && MapData[node + 1] != Room.RightDeadEnd)                        {                            new_frontier.Add(node + 1);                            visited.Add(node + 1);                        }                    }                }                if (new_frontier.Count == 0)                {                    for (int i = 0; i < frontier.Count; i++)                    {                        switch (MapData[frontier[i]])                        {                            case Room.Hall:                                MapData[frontier[i]] = Room.EndHall;                                FillNotVisited(visited, frontier);                                return depth;                            case Room.LeftDeadEnd:                                MapData[frontier[i]] = Room.EndLeftDeadEnd;                                FillNotVisited(visited, frontier);                                return depth;                            case Room.RightDeadEnd:                                MapData[frontier[i]] = Room.EndRightDeadEnd;                                FillNotVisited(visited, frontier);                                return depth;                            default:                                continue;                        }                    }                    return -1;                }                depth++;                frontier = new_frontier;            }        }        private void FillNotVisited(List<int> visited, List<int> frontier)        {            for (int i = 0; i < height; i++)            {                for (int j = 0; j < width; j++)                {                    if (!visited.Contains(i * width + j) && !frontier.Contains(i * width + j))                    {                        MapData[i * width + j] = Room.Full;                    }                }            }        }    }    public class Grid    {        public static int width = 105;        public static int height = 57;        public Cell[] GridData;                public List<Cell[]> StartList;        public List<Cell[]> HallList;        public List<Cell[]> DropTopList;        public List<Cell[]> DropBottomList;        public List<Cell[]> HallEndList;        public List<Cell[]> RightEndList;        public List<Cell[]> LeftEndList;        public Map SourceMap;        public int EnemyChance;        public int FillChance;                    public Grid(Map map)        {            GridData = new Cell[width * height];            Array.Fill(GridData, Cell.Empty);            StartList = new [] {new Cell[]            {                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,                Cell.Full, Cell.Full, Cell.PossibleFull, Cell.PossibleFull, Cell.Empty, Cell.PossibleFull, Cell.PossibleFull, Cell.Empty, Cell.PossibleFull,                Cell.Full, Cell.PossibleFull, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Full, Cell.PossibleFull, Cell.Empty, Cell.Spawn, Cell.Empty, Cell.Empty, Cell.NPC, Cell.Empty, Cell.Empty,                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,            }}.ToList();                        HallList = new [] {             // new Cell[]            // {            //     Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,            // },            // new Cell[]            // {            //     Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Full, Cell.Lava, Cell.Lava, Cell.Lava, Cell.Lava, Cell.Lava, Cell.Lava, Cell.Lava, Cell.Full,            //     Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,            // },            new Cell[]            {                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.PossibleFull, Cell.PossibleFull, Cell.Empty, Cell.Empty, Cell.PossibleFull, Cell.PossibleFull,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Duck, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty,                Cell.Full, Cell.Lava, Cell.Full, Cell.Lava, Cell.Full, Cell.Lava, Cell.Full, Cell.Lava, Cell.Full,                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,            },            new Cell[]            {                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,                Cell.PossibleFull, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.PossibleFull, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.PossibleFull, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Full, Cell.Lava, Cell.Lava, Cell.Lava, Cell.Lava, Cell.Lava, Cell.Lava, Cell.Lava, Cell.Full,                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,            },            new Cell[]            {                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.PossibleFull, Cell.Empty, Cell.Empty, Cell.Empty, Cell.PossibleFull, Cell.PossibleFull,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty,                Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty,                Cell.Full, Cell.Lava, Cell.Lava, Cell.Lava, Cell.Lava, Cell.Lava, Cell.Lava, Cell.Lava, Cell.Full,                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,            },            new Cell[]            {                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.PossibleFull,                Cell.Empty, Cell.PossibleFull, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.PossibleFull, Cell.PossibleFull, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Full, Cell.Lava, Cell.Full, Cell.Lava, Cell.Lava, Cell.Lava, Cell.Full, Cell.Lava, Cell.Full,                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,            },            new Cell[]            {                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,                Cell.PossibleFull, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Duck, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.PossibleFull, Cell.Empty, Cell.Empty, Cell.Empty, Cell.PossibleFull, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.PossibleFull, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Enemy, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Enemy, Cell.Empty, Cell.Empty,                Cell.Full, Cell.Lava, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Lava, Cell.Full,                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,            },            }.ToList();                        HallEndList = new [] {new Cell[]            {                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.PossibleFull, Cell.PossibleFull,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Win, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,            }}.ToList();                        DropTopList = new [] {            // new Cell[]            // {            //     Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full,            // },            new Cell[]            {                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Duck, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Full, Cell.Empty, Cell.Full, Cell.Full, Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Full,            },            new Cell[]            {                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Enemy, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Full, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Full, Cell.Empty, Cell.Empty,                Cell.Full, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full,            },            new Cell[]            {                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Duck,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Lava, Cell.Full,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Full, Cell.Full,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Decoration, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Full, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Enemy, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Full, Cell.Empty, Cell.Full, Cell.Full, Cell.Empty, Cell.Full, Cell.Full, Cell.Full, Cell.Full,            },            }.ToList();                        DropBottomList = new [] {            // new Cell[]            // {            //     Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,            //     Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,            // },            new Cell[]            {                Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Enemy, Cell.Empty, Cell.Decoration, Cell.Empty, Cell.Empty,                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,            },            new Cell[]            {                Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Full, Cell.Lava, Cell.Full, Cell.Lava, Cell.Full, Cell.Lava, Cell.Full, Cell.Lava, Cell.Full,                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,            },            new Cell[]            {                Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Full, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Decoration, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Full, Cell.Lava, Cell.Lava, Cell.Full, Cell.Full, Cell.Full, Cell.Lava, Cell.Lava, Cell.Full,                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,            },            new Cell[]            {                Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Enemy, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Full, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Full, Cell.Empty, Cell.Empty,                Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Decoration, Cell.Empty, Cell.Empty, Cell.Empty, Cell.Empty,                Cell.Full, Cell.Lava, Cell.Lava, Cell.Full, Cell.Full, Cell.Full, Cell.Lava, Cell.Lava, Cell.Full,                Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full, Cell.Full,            },            }.ToList();            for (int i = 0; i < width; i++)            {                GridData[i] = Cell.Full;                GridData[width * (height - 1) + i] = Cell.Full;            }            for (int i = 0; i < height; i++)            {                GridData[i * width] = Cell.Full;                GridData[(i + 1) * width - 1] = Cell.Full;            }            SourceMap = map;            EnemyChance = 35;            FillChance = 50;                        FillMap();            Display();        }        public void FillMap()        {            for (int i = 0; i < Map.height; i++)            {                for (int j = 0; j < Map.width; j++)                {                    Cell[] room;                    switch (SourceMap.MapData[i * Map.width + j])                    {                        case Room.Start:                            room = StartList[Map._rnd.Next(0, StartList.Count)];                            CopyRoom(room, (i * 8) * width + j * 8, false);                            break;                        case Room.Hall:                            room = HallList[Map._rnd.Next(0, HallList.Count)];                            CopyRoom(room, (i * 8) * width + j * 8, true);                            break;                        case Room.RightDeadEnd:                            room = HallList[Map._rnd.Next(0, HallList.Count)];                            CopyRoom(room, (i * 8) * width + j * 8, false);                            break;                        case Room.LeftDeadEnd:                            room = HallList[Map._rnd.Next(0, HallList.Count)];                            CopyRoom(room, (i * 8) * width + j * 8, false);                            break;                        case Room.DropBottom:                            room = DropBottomList[Map._rnd.Next(0, DropBottomList.Count)];                            CopyRoom(room, (i * 8) * width + j * 8, true);                            break;                        case Room.DropTop:                            room = DropTopList[Map._rnd.Next(0, DropTopList.Count)];                            CopyRoom(room, (i * 8) * width + j * 8, true);                            break;                        case Room.EndHall:                            room = HallEndList[Map._rnd.Next(0, HallEndList.Count)];                            CopyRoom(room, (i * 8) * width + j * 8, true);                            break;                        case Room.EndRightDeadEnd:                            room = HallEndList[Map._rnd.Next(0, HallEndList.Count)];                            CopyRoom(room, (i * 8) * width + j * 8, false);                            break;                        case Room.EndLeftDeadEnd:                            room = HallEndList[Map._rnd.Next(0, HallEndList.Count)];                            CopyRoom(room, (i * 8) * width + j * 8, false);                            break;                        case Room.Full:                            FillRoom((i * 8) * width + j * 8);                            break;                        default:                            Console.WriteLine(SourceMap.MapData[i * Map.width + j]);                            DebugRoom((i * 8) * width + j * 8);                            break;                    }                }            }        }        public void CopyRoom(Cell[] room, int start, bool flippable)        {            if (flippable && Map._rnd.Next(0, 2) == 1)            {                for (int i = 0; i < 9; i++)                {                    for (int j = 0; j < 9; j++)                    {                        if (GridData[start + (i * width) + j] == Cell.Empty)                        {                            switch (room[i * 9 + (8 - j)])                            {                                case Cell.Enemy:                                    if (Map._rnd.Next(0, 100) < EnemyChance)                                    {                                        GridData[start + (i * width) + j] = Cell.Enemy;                                    }                                    else                                    {                                        GridData[start + (i * width) + j] = Cell.Empty;                                    }                                    break;                                case Cell.PossibleFull:                                    if (Map._rnd.Next(0, 100) < FillChance)                                    {                                        GridData[start + (i * width) + j] = Cell.Full;                                    }                                    else                                    {                                        GridData[start + (i * width) + j] = Cell.Empty;                                    }                                    break;                                default:                                    GridData[start + (i * width) + j] = room[i * 9 + (8 - j)];                                    break;                            }                        }                    }                }            }            else            {                for (int i = 0; i < 9; i++)                {                    for (int j = 0; j < 9; j++)                    {                        if (GridData[start + (i * width) + j] == Cell.Empty)                        {                            switch (room[i * 9 + j])                            {                                case Cell.Enemy:                                    if (Map._rnd.Next(0, 100) < EnemyChance)                                    {                                        GridData[start + (i * width) + j] = Cell.Enemy;                                    }                                    else                                    {                                        GridData[start + (i * width) + j] = Cell.Empty;                                    }                                    break;                                case Cell.PossibleFull:                                    if (Map._rnd.Next(0, 100) < FillChance)                                    {                                        GridData[start + (i * width) + j] = Cell.Full;                                    }                                    else                                    {                                        GridData[start + (i * width) + j] = Cell.Empty;                                    }                                    break;                                default:                                    GridData[start + (i * width) + j] = room[i * 9 + j];                                    break;                            }                        }                    }                }            }        }                public void FillRoom(int start)        {            for (int i = 0; i < 9; i++)            {                for (int j = 0; j < 9; j++)                {                    GridData[start + (i * width) + j] = Cell.Full;                }            }        }                public void DebugRoom(int start)        {            for (int i = 0; i < 9; i++)            {                for (int j = 0; j < 9; j++)                {                    GridData[start + (i * width) + j] = Cell.Debug;                }            }        }        public void Display()        {            for (int i = 0; i < height; i++)            {                for (int j = 0; j < width; j++)                {                    switch (GridData[i * width + j])                    {                        case Cell.Full:                            Console.Write("G");                            break;                        case Cell.Empty:                            Console.Write(" ");                            break;                        case Cell.Spawn:                            Console.Write("S");                            break;                        case Cell.Win:                            Console.Write("W");                            break;                        case Cell.Debug:                            Console.Write("$");                            break;                        case Cell.Lava:                            Console.Write("~");                            break;                        case Cell.Duck:                            Console.Write("D");                            break;                        case Cell.Decoration:                            Console.Write("*");                            break;                        case Cell.Enemy:                            Console.Write("E");                            break;                        case Cell.NPC:                            Console.Write("N");                            break;                        default:                            Console.Write("?");                            break;                    }                    Console.Write(" ");                }                Console.WriteLine();            }        }    }}